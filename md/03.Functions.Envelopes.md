
## Variables, Envelopes, and Scope

Note: Introduce scope as “where a variable lives and can be accessed.”

---H

### Scope

- Scope = where in your code a variable exists
- Think of it like a boundary or container
- JavaScript has **block scope** with `let` and `const`

Note: Compare to rehearsal spaces — instruments stay in their own room unless brought out.

---H

### Block Scope Example

```js
{
  let a = 10;
  const b = 20;
  console.log(a, b); // works
}

console.log(a, b); // error!
````

* `a` and `b` only exist inside the `{ }`
* Outside, they are undefined

Note: Stress that curly braces `{}` create a scope.

---H

### Why `let` and `const`?

* `var` (old keyword) ignores block scope
* `let` and `const` respect block scope
* `const` means the variable name cannot be reassigned
* Use `const` by default, `let` if you need to reassign

Note: Encourage best practice — mostly use `const`.

---H

# Functions in JavaScript

Note: Transition into functions — functions also create their own scope.

---H

### What is a Function?

* A reusable block of code
* You "call" it when you want it to run
* Can take inputs (parameters)
* Can give back outputs (return values)

Note: Compare to a musical phrase: you write it once, perform it many times.

---H

### Declaring a Function

```js
const greet = function() {
  console.log("Hello!");
};
```

* `const` &rarr; creates a variable
* `function()` &rarr; defines the function
* `{}` &rarr; holds the code inside

Note: Emphasize the syntax: const + = function() + curly braces.

---H

### Calling a Function

```js
const greet = function() {
  console.log("Hello!");
};

greet(); // runs the function
```

Note: Stress the parentheses at the end — they make the function run.

---H

### Functions and Scope

```js
const showMessage = function() {
  const message = "Hello from inside!";
  console.log(message);
};

showMessage(); // works
console.log(message); // error!
```

* Variables declared inside a function live only inside
* Each function has its own scope

Note: Connect back to block scope. Functions add their own “room.”

---H

### Functions With Parameters

```js
const greet = function(name) {
  console.log("Hello " + name + "!");
};

greet("Alice");
greet("Bob");
```

Note: Parameters are placeholders. Students should see how input changes output.

---H

### Functions That Return Values

```js
const add = function(x, y) {
  return x + y;
};

const result = add(2, 3);
console.log(result); // 5
```

* `return` sends a value back to where the function was called
* That value can be stored in a variable or used in another calculation

Note: Stress that `return` is how a function gives back a result.

---H

### Return vs. Console.log

```js
const add = function(x, y) {
  console.log(x + y);
};

const result = add(2, 3);
console.log(result); // undefined
```

* `console.log()` only prints to the screen
* It does NOT give back a usable value
* Without `return`, functions give back `undefined`

Note: Show that printing is not the same as returning.

---H

### Why Do We Need `return`?

* To **use the output later**
* To **combine functions** together
* To keep logic flexible

Example:

```js
const square = function(n) {
  return n * n;
};

const sumOfSquares = function(a, b) {
  return square(a) + square(b);
};

console.log(sumOfSquares(2, 3)); // 13
```

Note: Emphasize that return lets functions be building blocks for bigger ideas.

---H

## Controlling Sound Over Time (Gain Envelopes)

Note: Introduce scheduling with `currentTime` and `linearRampToValueAtTime`.

---H

### Key Ideas for Ramping

* `ctx.currentTime` = now (in seconds)
* Always **set a starting value** before ramping
* Use `linearRampToValueAtTime(target, when)`
* Small fades avoid clicks (e.g., 0.01&ndash;0.02s)

Note: MDN convention is `setValueAtTime` &rarr; then ramp. Prevents jumps/clicks.

---H

### Click-Safe Start (Fade-In)

```js
const startTone = function(ctx, freq, duration) {
  const osc = new OscillatorNode(ctx, { frequency: freq });
  const gain = new GainNode(ctx, { gain: 0.0 }); // start silent
  osc.connect(gain).connect(ctx.destination);

  const now = ctx.currentTime;

  gain.gain.setValueAtTime(0.0, now);
  gain.gain.linearRampToValueAtTime(0.2, now + 0.02); // 20 ms fade-in

  osc.start(now);
  osc.stop(now + duration);

  return { osc, gain };
};
```

* Begin at 0, ramp up a little &rarr; no pop
* Keep a reference if you'll ramp back down later

Note: Use a conservative target like 0.2 to protect ears.

---H

### Click-Safe Stop (Fade-Out)

```js
const stopTone = function(ctx, voice) {
  const now = ctx.currentTime;

  voice.gain.gain.cancelScheduledValues(now);
  voice.gain.gain.setValueAtTime(voice.gain.gain.value, now);
  voice.gain.gain.linearRampToValueAtTime(0.0, now + 0.02); // 20 ms fade-out

  voice.osc.stop(now + 0.03); // stop after fade reaches 0
};
```

* Cancel future ramps first
* Pin the current value with `setValueAtTime`
* Ramp to 0, then stop a bit after

Note: This pattern generalizes to any node you want to fade.

---H

### Simple ADS-like Envelope (A/D only)

```js
const triggerAD = function(ctx, freq, A, D, peak, sustain) {
  const osc = new OscillatorNode(ctx, { frequency: freq });
  const gain = new GainNode(ctx, { gain: 0.0 });
  osc.connect(gain).connect(ctx.destination);

  const now = ctx.currentTime;

  gain.gain.setValueAtTime(0.0, now);               // start at 0
  gain.gain.linearRampToValueAtTime(peak, now + A);  // Attack to peak
  gain.gain.linearRampToValueAtTime(sustain, now + A + D); // Decay to sustain

  osc.start(now);

  return { osc, gain, startedAt: now, A, D };
};
```

* `A` = attack time, `D` = decay time (seconds)
* `peak` and `sustain` are linear gains (0&ndash;1)

Note: Keep parameters musical: short A for plucks, longer A for pads.

---H

### Releasing the Note (D &rarr; 0)

```js
const releaseNote = function(ctx, voice, releaseTime) {
  const now = ctx.currentTime;

  voice.gain.gain.cancelScheduledValues(now);
  voice.gain.gain.setValueAtTime(voice.gain.gain.value, now);
  voice.gain.gain.linearRampToValueAtTime(0.0, now + releaseTime);

  voice.osc.stop(now + releaseTime + 0.01);
};
```

* Use `cancelScheduledValues` before new ramps
* Smooth release avoids zipper noise/clicks

Note: Never stop immediately at non-zero gain.

---H

### One-Shot: Fade In &rarr; Hold &rarr; Fade Out

```js
const oneShot = function(ctx, freq, fadeIn, hold, fadeOut, level) {
  const osc = new OscillatorNode(ctx, { frequency: freq });
  const gain = new GainNode(ctx, { gain: 0.0 });
  osc.connect(gain).connect(ctx.destination);

  const now = ctx.currentTime;

  gain.gain.setValueAtTime(0.0, now);
  gain.gain.linearRampToValueAtTime(level, now + fadeIn);            // in
  gain.gain.setValueAtTime(level, now + fadeIn + hold);               // hold
  gain.gain.linearRampToValueAtTime(0.0, now + fadeIn + hold + fadeOut); // out

  osc.start(now);
  osc.stop(now + fadeIn + hold + fadeOut + 0.01);
};
```

* Great for percussive blips or whooshes
* All times are in seconds

Note: Use this as a building block for rhythmic sequencing later.

---H

### A Quick Note on Arrow Functions

```js
// function expression
const square = function(n) {
  return n * n;
};

// arrow function
const squareArrow = (n) => {
  return n * n;
};
```

* Shorter syntax
* Still stored in a `const`
* Works the same way

Note: Arrow functions are shorthand; we'll keep using the long form for clarity.

---H

## Arrow Functions Can Be Even Shorter

```js
const square = (n) => n * n;
```

* If only one line &rarr; no `{}` or `return` needed
* If one parameter &rarr; parentheses optional

Note: Compact is nice, but clarity first.

---H

# Wrap Up

* Scope = where variables live; `let`/`const` are block-scoped
* Functions create their own scope
* Use `const name = function() {}` to define; call with `name()`
* `return` makes functions composable and reusable
* For audio, schedule with `ctx.currentTime`
* **Ramps**: set a start value &rarr; `linearRampToValueAtTime`
* Fade-in/out prevents clicks; cancel before new ramps
* Arrow functions are a shorter way to write the same thing

Note: Next time we'll chain envelopes with pitch changes and timing utilities.



---H

